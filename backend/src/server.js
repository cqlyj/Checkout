require("dotenv").config({
  path: require("path").join(__dirname, "../../frontend/.env.local"),
});
const path = require("path");
const Fastify = require("fastify");
const cors = require("@fastify/cors");
const { createClient } = require("@supabase/supabase-js");
const { z } = require("zod");
const circomlib = require("circomlibjs");
const snarkjs = require("snarkjs");
const fs = require("fs");

const app = Fastify({ logger: true });
app.register(cors, { origin: true, credentials: false });

const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;
if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
  app.log.warn("Supabase env vars missing.");
}
const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, {
  auth: { persistSession: false, autoRefreshToken: false },
});

// Preload artifacts from existing project paths
// wasm generated by circom compilation under outputs/pinVerification_js/
const WASM_PATH = path.resolve(
  __dirname,
  "../../zk/outputs/pinVerification_js/pinVerification.wasm"
);
// zkey produced during setup is located under outputs/
const ZKEY_PATH = path.resolve(
  __dirname,
  "../../zk/outputs/pinVerification.zkey"
);
let wasmBuffer;
let zkeyBuffer;
function ensureArtifacts() {
  if (!wasmBuffer) wasmBuffer = fs.readFileSync(WASM_PATH);
  if (!zkeyBuffer) zkeyBuffer = fs.readFileSync(ZKEY_PATH);
}

// Helpers
function toPgBytea(hex) {
  const clean = (hex.startsWith("0x") ? hex.slice(2) : hex).toLowerCase();
  return `\\x${clean}`;
}

async function issueNonce(walletAddressHex, intent) {
  const walletBytes = toPgBytea(walletAddressHex);
  // naive nonce: timestamp ms; for multi-issue, you can add a counter
  const nonce = Date.now();
  const { error } = await supabase.from("zk_nonces").insert({
    wallet_address_bytes: walletBytes,
    intent,
    nonce,
  });
  if (error) throw new Error(error.message);
  return nonce;
}

async function consumeNonce(walletAddressHex, intent, nonce) {
  const walletBytes = toPgBytea(walletAddressHex);
  const { data, error } = await supabase
    .from("zk_nonces")
    .select("used")
    .eq("wallet_address_bytes", walletBytes)
    .eq("intent", intent)
    .eq("nonce", nonce)
    .limit(1)
    .maybeSingle();
  if (error) throw new Error(error.message);
  if (!data) throw new Error("Nonce not found");
  if (data.used) throw new Error("Nonce already used");
  const { error: upErr } = await supabase
    .from("zk_nonces")
    .update({ used: true, used_at: new Date().toISOString() })
    .eq("wallet_address_bytes", walletBytes)
    .eq("intent", intent)
    .eq("nonce", nonce);
  if (upErr) throw new Error(upErr.message);
}

// Routes
app.post("/api/zk/nonce", async (req, reply) => {
  const schema = z.object({
    walletAddress: z.string().regex(/^0x[0-9a-fA-F]{40}$/),
    intent: z.number().int().min(0).max(1),
  });
  const parse = schema.safeParse(req.body);
  if (!parse.success) return reply.code(400).send({ error: "Invalid input" });
  const { walletAddress, intent } = parse.data;
  try {
    const nonce = await issueNonce(walletAddress, intent);
    return { nonce };
  } catch (e) {
    return reply.code(500).send({ error: e.message });
  }
});

app.post("/api/zk/proof", async (req, reply) => {
  const schema = z.object({
    walletAddress: z.string().regex(/^0x[0-9a-fA-F]{40}$/),
    pin: z.string().regex(/^\d{6}$/),
    intent: z.number().int().min(0).max(1),
    nonce: z.number().int(),
  });
  const parse = schema.safeParse(req.body);
  if (!parse.success) return reply.code(400).send({ error: "Invalid input" });
  const { walletAddress, pin, intent, nonce } = parse.data;
  try {
    await consumeNonce(walletAddress, intent, nonce);
    ensureArtifacts();
    const poseidon = await circomlib.buildPoseidon();
    const F = poseidon.F;
    const walletBig = BigInt(walletAddress);
    const pinBig = BigInt(pin);
    const credentialHash = poseidon([walletBig, pinBig, BigInt(intent)]);
    const credentialHashStr = F.toString(credentialHash);
    const resultHash = poseidon([credentialHash, BigInt(nonce)]);
    const resultHashStr = F.toString(resultHash);
    const input = {
      pin: pinBig.toString(),
      walletAddress: walletBig.toString(),
      intent: BigInt(intent).toString(),
      credential_hash: credentialHashStr,
      nonce: BigInt(nonce).toString(),
      result_hash: resultHashStr,
    };
    const { proof, publicSignals } = await snarkjs.groth16.fullProve(
      input,
      wasmBuffer,
      zkeyBuffer
    );
    return {
      proof,
      publicSignals,
      credentialHash: credentialHashStr,
      resultHash: resultHashStr,
    };
  } catch (e) {
    return reply.code(500).send({ error: e.message });
  }
});

const PORT = process.env.ZK_BACKEND_PORT
  ? Number(process.env.ZK_BACKEND_PORT)
  : 8787;
app.listen({ host: "0.0.0.0", port: PORT }).then(() => {
  app.log.info(`zk backend listening on :${PORT}`);
});
